# Resume-Based Template Generation Feature - Implementation Plan

## Overview

Implement a feature allowing users to upload resumes (PDF) to Supabase Storage and generate personalized cold email templates using AI. The feature follows existing codebase patterns and architectural decisions.

**Template Generation Limit**: Each user can generate a maximum of 5 templates. This limit is tracked in the database (`users.template_count`) and enforced by both backend (429 error) and frontend (disabled button). The frontend fetches the count from the API instead of using localStorage, ensuring the limit persists across devices and browsers.

## Architecture Decisions

Based on user requirements and existing patterns:

- **Upload Flow**: Frontend → Supabase Storage (direct upload using frontend's authenticated Supabase client)
- **Generation**: Synchronous API call (5-15 second response, like `/api/user/init`)
- **Resume Policy**: Single resume per user (uploading new resume overwrites old)
- **Template Mutability**: Immutable (create/delete only, no editing)
- **Backend-First**: Backend validates JWT, performs all database operations
- **Generation Tracking**: Database-backed (`users.template_count`) instead of localStorage for cross-device persistence

## Migration from localStorage to Database Tracking

**Current State** (localStorage-based):
- Frontend stores `templateGenerations_${user.uid}` in localStorage
- Limit only applies to single browser/device
- Can be manipulated by user via DevTools
- Not synchronized across sessions

**New State** (database-backed):
- `users.template_count` column tracks generations per user
- Backend enforces limit with 429 error when count >= 5
- Frontend fetches count from `/api/user/profile` endpoint
- Limit persists across all devices and browsers
- Single source of truth in database

**Implementation Steps**:
1. Add `template_count` column to `users` table (Phase 2)
2. Backend increments count on template creation (Phase 7)
3. Backend returns 429 when limit reached (Phase 7)
4. Frontend fetches count from API instead of localStorage (Phase 9)
5. Remove all localStorage read/write operations (Phase 9)

## Implementation Phases

### Phase 1: Configuration & Settings (30 min)

**File**: `config/settings.py`

Add Supabase Storage configuration:
```python
# Supabase Storage
supabase_storage_bucket: str = Field(default="resumes")
```

**File**: `.env` / `.env.example`

Add environment variables (with defaults above, these are optional):
```
SUPABASE_STORAGE_BUCKET=resumes
```

### Phase 2: Database Models (1 hour)

**File**: `models/template.py` (Currently incomplete - needs implementation)

Complete the Template model following patterns from `models/email.py`:
```python
from uuid import uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Index
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database.base import Base

class Template(Base):
    __tablename__ = "templates"

    # Columns
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PG_UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    pdf_url = Column(String(500), nullable=False, comment="Supabase Storage URL for resume PDF")
    template_text = Column(Text, nullable=False, comment="Generated template content")
    user_instructions = Column(Text, nullable=False, comment="User guidance for template generation")
    created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)

    # Relationships
    user = relationship("User", back_populates="templates")

    # Indexes
    __table_args__ = (
        Index('ix_templates_user_id', 'user_id'),
        Index('ix_templates_created_at', 'created_at'),
        Index('ix_templates_user_created', 'user_id', 'created_at'),
    )

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "pdf_url": self.pdf_url,
            "template_text": self.template_text,
            "user_instructions": self.user_instructions,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }
```

**File**: `models/user.py`

Add template tracking and relationship:
```python
# Add after generation_count field
template_count = Column(
    Integer,
    nullable=False,
    default=0,
    comment="Number of templates generated by this user"
)

# Add to relationships section
templates = relationship(
    "Template",
    back_populates="user",
    cascade="all, delete-orphan",
    lazy="dynamic"
)
```

Update `to_dict()` method to include `template_count`.

**File**: `models/__init__.py`

Add Template import:
```python
from models.template import Template
__all__ = ["User", "Email", "Template"]
```

**Database Migration**:
```bash
alembic revision --autogenerate -m "add templates table and template_count to users"
alembic upgrade head
```

### Phase 4: PDF Parsing Utility (1 hour)

**File**: `utils/pdf_parser.py` (NEW)

Create PDF text extraction utility:
```python
"""PDF parsing utilities for resume text extraction."""

import httpx
from pypdf import PdfReader
from io import BytesIO

async def extract_text_from_url(pdf_url: str, timeout: int = 30) -> str:
    """
    Fetch PDF from URL and extract text content.

    Args:
        pdf_url: Public URL to PDF file
        timeout: Request timeout in seconds

    Returns:
        Extracted text content

    Raises:
        ValueError: If PDF is invalid or text extraction fails
    """
    async with httpx.AsyncClient(timeout=timeout) as client:
        response = await client.get(pdf_url)
        response.raise_for_status()

        pdf_bytes = BytesIO(response.content)
        reader = PdfReader(pdf_bytes)

        if len(reader.pages) == 0:
            raise ValueError("PDF has no pages")

        text = ""
        for page in reader.pages:
            text += page.extract_text()

        text = clean_text(text)

        if len(text) < 50:
            raise ValueError("PDF appears to be scanned or contains too little text")

        return text

def clean_text(raw_text: str) -> str:
    """Clean and normalize extracted PDF text."""
    # Remove excessive whitespace
    text = " ".join(raw_text.split())
    return text.strip()
```

**Update**: `requirements.txt`
```
pypdf>=5.1.0,<6.0.0
httpx>=0.27.0,<1.0.0
```

### Phase 5: Template Generation Service (2 hours)

**File**: `prompts/template_generation.md` (NEW)

Create system prompt for template generation:
```markdown
You are an expert cold email writer helping users create personalized outreach templates for academic research opportunities.

Given a user's resume and specific instructions, generate a professional yet warm cold email template that:

1. **Length**: 150-250 words
2. **Tone**: Professional but personable, enthusiastic about research
3. **Structure**: Clear introduction, brief background, specific interest, polite ask
4. **Placeholders**: Use {{professor_name}}, {{university}}, {{research_area}} for personalization
5. **Resume Integration**: Naturally weave in relevant experience from the resume (courses, projects, skills)
6. **Customization**: Follow user's tone/style preferences from their instructions

IMPORTANT:
- DO NOT make up specific details about professors or their research
- Keep placeholders generic for later customization
- Highlight 2-3 relevant experiences from resume
- End with clear but non-pushy call-to-action
- Avoid clichés like "passionate" overuse

Output ONLY the email template text, no preamble or explanation.
```

**File**: `services/template_generator.py` (NEW)

Create template generation service:
```python
"""Template generation service using AI."""

import logfire
from utils.llm_agent import run_agent
from utils.pdf_parser import extract_text_from_url
from pathlib import Path

PROMPT_PATH = Path(__file__).parent.parent / "prompts" / "template_generation.md"

async def generate_template_from_resume(
    pdf_url: str,
    user_instructions: str,
    model: str = "anthropic:claude-sonnet-4.5-20250929"
) -> str:
    """
    Generate email template from resume PDF and user instructions.

    Args:
        pdf_url: Public URL to resume PDF in Supabase Storage
        user_instructions: User guidance for template generation
        model: AI model to use

    Returns:
        Generated template text

    Raises:
        ValueError: If PDF parsing fails or generation fails
    """
    with logfire.span("template_generation.generate"):
        # Extract text from PDF
        logfire.info("Extracting text from PDF", pdf_url=pdf_url)
        resume_text = await extract_text_from_url(pdf_url)
        logfire.info("PDF text extracted", length=len(resume_text))

        # Load system prompt
        system_prompt = PROMPT_PATH.read_text()

        # Create user prompt
        user_prompt = f"""**RESUME:**
{resume_text}

**USER INSTRUCTIONS:**
{user_instructions}

Generate a cold email template following the guidelines."""

        # Generate template using AI
        logfire.info("Generating template with AI")
        template_text = await run_agent(
            prompt=user_prompt,
            model=model,
            system_prompt=system_prompt,
            temperature=0.8,
            max_tokens=1500,
            retries=3,
            timeout=45.0
        )

        logfire.info("Template generated", length=len(template_text))
        return template_text
```

### Phase 6: API Schemas (45 min)

**File**: `schemas/template.py` (NEW)

Create Pydantic schemas:
```python
"""Pydantic schemas for template API endpoints."""

from pydantic import BaseModel, Field, ConfigDict, field_validator
from datetime import datetime
import uuid

class GenerateTemplateRequest(BaseModel):
    """Request schema for generating a template."""
    pdf_url: str = Field(..., min_length=10, max_length=500, description="Public URL to resume PDF")
    user_instructions: str = Field(..., min_length=10, max_length=2000, description="Guidance for template generation")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "pdf_url": "https://...",
                "user_instructions": "Create a warm, enthusiastic template highlighting my ML research experience"
            }
        }
    )

class TemplateResponse(BaseModel):
    """Response schema for template data."""
    id: uuid.UUID
    user_id: uuid.UUID
    pdf_url: str
    template_text: str
    user_instructions: str
    created_at: datetime

    model_config = ConfigDict(
        from_attributes=True,
        json_schema_extra={
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "user_id": "660e8400-e29b-41d4-a716-446655440001",
                "pdf_url": "https://...",
                "template_text": "Dear {{professor_name}}...",
                "user_instructions": "Warm and enthusiastic",
                "created_at": "2025-01-13T10:30:00Z"
            }
        }
    )

class ResumeUrlResponse(BaseModel):
    """Response schema for user's resume URL."""
    resume_url: str | None = Field(..., description="Public URL to user's resume, or null if none")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {"resume_url": "https://..."}
        }
    )
```

**File**: `schemas/auth.py`

Update UserResponse schema to include `template_count`:
```python
# Add to UserResponse class after generation_count
template_count: int = Field(default=0, description="Number of templates generated")

# Update example in model_config
"generation_count": 5,
"template_count": 3,  # ADD THIS LINE
"created_at": "2024-01-13T10:30:00Z",
```

### Phase 7: API Endpoints (3 hours)

**File**: `api/routes/template.py` (NEW)

Create template routes following patterns from `api/routes/user.py`:
```python
"""Template management API endpoints."""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
import logfire

from models.user import User
from models.template import Template
from database import get_db
from api.dependencies import get_current_user
from schemas.template import (
    GenerateTemplateRequest, TemplateResponse
)
from services.supabase import get_public_url
from services.template_generator import generate_template_from_resume
from utils.uuid_helpers import ensure_uuid
from config import settings

router = APIRouter(prefix="/api/templates", tags=["Templates"])

@router.post("/", response_model=TemplateResponse, status_code=status.HTTP_201_CREATED)
async def create_template(
    request: GenerateTemplateRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Generate template from resume and user instructions.

    Synchronous operation (5-15 seconds). Creates Template record and increments user.template_count.
    
    **Rate Limit**: Maximum 5 templates per user.
    """
    with logfire.span("api.create_template", user_id=str(current_user.id)):
        try:
            # Check template generation limit (5 templates max)
            if current_user.template_count >= 5:
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail="Template generation limit reached. Maximum 5 templates allowed per user."
                )
            
            # Generate template
            template_text = await generate_template_from_resume(
                pdf_url=request.pdf_url,
                user_instructions=request.user_instructions
            )

            # Create database record
            new_template = Template(
                user_id=current_user.id,
                pdf_url=request.pdf_url,
                template_text=template_text,
                user_instructions=request.user_instructions
            )

            db.add(new_template)
            current_user.template_count += 1
            db.commit()
            db.refresh(new_template)

            logfire.info("Template created", template_id=str(new_template.id))
            return new_template

        except ValueError as e:
            db.rollback()
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Template generation failed: {str(e)}"
            )
        except Exception as e:
            db.rollback()
            logfire.error("Template creation failed", error=str(e))
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to create template"
            )

@router.get("/", response_model=list[TemplateResponse])
async def list_templates(
    limit: int = 20,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """List user's templates (paginated, newest first)."""
    with logfire.span("api.list_templates"):
        templates = db.query(Template).filter(
            Template.user_id == current_user.id
        ).order_by(
            Template.created_at.desc()
        ).limit(min(limit, 100)).offset(offset).all()

        return templates

@router.get("/{template_id}", response_model=TemplateResponse)
async def get_template(
    template_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get specific template by ID."""
    with logfire.span("api.get_template", template_id=template_id):
        try:
            template_uuid = ensure_uuid(template_id)
        except ValueError as e:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid template ID: {str(e)}"
            )

        template = db.query(Template).filter(
            Template.id == template_uuid,
            Template.user_id == current_user.id
        ).first()

        if not template:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Template not found"
            )

        return template

@router.delete("/{template_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_template(
    template_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Delete template by ID."""
    with logfire.span("api.delete_template", template_id=template_id):
        try:
            template_uuid = ensure_uuid(template_id)
        except ValueError as e:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid template ID: {str(e)}"
            )

        template = db.query(Template).filter(
            Template.id == template_uuid,
            Template.user_id == current_user.id
        ).first()

        if not template:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Template not found"
            )

        db.delete(template)
        current_user.template_count = max(0, current_user.template_count - 1)
        db.commit()

        logfire.info("Template deleted", template_id=template_id)
```

**File**: `api/routes/user.py`

Add resume URL endpoint:
```python
@router.get("/resume-url", response_model=ResumeUrlResponse)
async def get_resume_url(
    current_user: User = Depends(get_current_user),
):
    """Get public URL to user's resume."""
    from services.supabase import get_public_url
    from config import settings

    file_path = f"{current_user.id}/resume.pdf"
    resume_url = get_public_url(settings.supabase_storage_bucket, file_path)
    return ResumeUrlResponse(resume_url=resume_url)
```

**File**: `api/routes/__init__.py`

Export template router:
```python
from api.routes.template import router as template_router
__all__ = ["user_router", "email_router", "template_router"]
```

**File**: `main.py`

Include template router:
```python
from api.routes import user_router, email_router, template_router
app.include_router(template_router)
```

### Phase 8: Supabase Storage Policies

Configure in Supabase Dashboard:

**Bucket Setup**:
- Bucket name: `resumes`
- Public: Yes (for read access)
- File size limit: 5MB

**Storage Policies** (SQL):
```sql
-- Allow authenticated users to upload to their own folder
CREATE POLICY "Users can upload to own folder"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK (
    bucket_id = 'resumes'
    AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Allow public read access
CREATE POLICY "Public read access"
ON storage.objects FOR SELECT TO public
USING (bucket_id = 'resumes');

-- Allow users to update their own files
CREATE POLICY "Users can update own files"
ON storage.objects FOR UPDATE TO authenticated
USING (
    bucket_id = 'resumes'
    AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Allow users to delete their own files
CREATE POLICY "Users can delete own files"
ON storage.objects FOR DELETE TO authenticated
USING (
    bucket_id = 'resumes'
    AND (storage.foldername(name))[1] = auth.uid()::text
);
```

### Phase 9: Frontend Integration - Replace localStorage with API (1 hour)

**Overview**: Replace localStorage-based template generation tracking with server-side tracking via the user profile API.

**File**: `app/dashboard/template/page.tsx`

Remove localStorage logic and use API:
```typescript
// REMOVE these lines (48-71):
// useEffect(() => {
//   if (user && user.uid) {
//     const storageKey = `templateGenerations_${user.uid}`;
//     const storedCount = localStorage.getItem(storageKey);
//     ...
//   }
// }, [user]);

// REPLACE with API call to get user profile:
useEffect(() => {
  const fetchUserProfile = async () => {
    if (!user) return;
    
    try {
      const response = await fetch(`${API_ENDPOINTS.base}/api/user/profile`, {
        headers: {
          'Authorization': `Bearer ${await user.getIdToken()}`,
        },
      });
      
      if (response.ok) {
        const userData = await response.json();
        const remaining = MAX_GENERATIONS - userData.template_count;
        setGenerationsLeft(Math.max(0, remaining));
      }
    } catch (error) {
      console.error('Failed to fetch user profile:', error);
    }
  };
  
  fetchUserProfile();
}, [user]);

// REMOVE localStorage updates (lines 96-101):
// const newCount = generationsLeft - 1;
// setGenerationsLeft(newCount);
// if (user && user.uid) {
//   localStorage.setItem(`templateGenerations_${user.uid}`, String(newCount));
// }

// REPLACE with optimistic UI update (backend will increment on success):
// After successful template generation, decrement locally:
setGenerationsLeft(prev => Math.max(0, prev - 1));
```

**Key Changes**:
1. Fetch `template_count` from `/api/user/profile` on mount
2. Calculate `generationsLeft = 5 - template_count`
3. Remove all localStorage read/write operations
4. Backend increments count automatically when template is created
5. Frontend updates optimistically after successful generation

**Benefits**:
- Single source of truth (database)
- Limit persists across devices/browsers
- No localStorage manipulation
- Consistent with email generation pattern

## Implementation Order

1. **Phase 1**: Configuration (30 min)
2. **Phase 2**: Database models + migration (1 hour)
3. **Phase 3**: Supabase storage utility functions (15 min)
4. **Phase 4**: PDF parsing utility (1 hour)
5. **Phase 6**: API schemas (30 min) - *Do before Phase 5*
6. **Phase 5**: Template generation service (2 hours)
7. **Phase 7**: API endpoints (2.5 hours)
8. **Phase 8**: Supabase policies (15 min via dashboard)
9. **Phase 9**: Frontend integration (1 hour)

**Total: ~9 hours**

## Testing Checklist

**Backend Tests**:
- [ ] Upload PDF directly from frontend to Supabase Storage
- [ ] Generate template with uploaded PDF URL
- [ ] Verify `template_count` increments in database after generation
- [ ] Test 5-template limit (6th generation should return 429 error)
- [ ] Get user profile returns correct `template_count`
- [ ] List templates (pagination)
- [ ] Get specific template
- [ ] Delete template (verify count decrements)
- [ ] Test authorization (can't access other user's templates)
- [ ] Test with scanned PDF (should fail gracefully)
- [ ] Test with corrupted PDF (should fail gracefully)
- [ ] Verify single-resume policy (upload overwrites)

**Frontend Tests**:
- [ ] Generation count loads from API on page mount
- [ ] Button shows correct "X uses left" text
- [ ] Button disables when limit reached
- [ ] localStorage is NOT used (verify in DevTools)
- [ ] Count persists across browser sessions/devices
- [ ] Optimistic UI update after successful generation

## Security Considerations

✅ **Implemented**:
- JWT validation + local database check
- User ID from JWT only (never request body)
- Queries filtered by user_id
- Frontend uploads directly using authenticated Supabase client
- 404 instead of 403 (prevents info leakage)
- Input validation (pdf_url, instructions length)
- Timeout on generation (45s)

⚠️ **To Configure in Supabase**:
- 5MB file size limit in bucket settings
- Proper MIME type validation in storage policies

## Critical Files Reference

**Models**:
- `models/template.py` - Complete Template model
- `models/user.py` - Add template_count and relationship

**Services**:
- `services/supabase.py` - Add storage functions
- `services/template_generator.py` - NEW: AI generation logic

**Utils**:
- `utils/pdf_parser.py` - NEW: PDF text extraction

**Schemas**:
- `schemas/template.py` - NEW: All template schemas
- `schemas/auth.py` - Update UserResponse

**Routes**:
- `api/routes/template.py` - NEW: 5 template endpoints
- `api/routes/user.py` - Add resume URL endpoint

**Config**:
- `config/settings.py` - Add storage settings
- `prompts/template_generation.md` - NEW: System prompt

## Notes

- Follow existing patterns from `models/email.py` and `api/routes/user.py`
- Use `logfire.span()` for observability on all operations
- Synchronous generation means users wait 5-15 seconds for response
- Single-resume policy simplifies storage management
- Templates are immutable (no edit endpoint needed)

## Quick Reference: Template Generation Limit

**Database Schema**:
```sql
-- users table
template_count INTEGER NOT NULL DEFAULT 0
```

**Backend Endpoints**:
```python
# Get user profile (includes template_count)
GET /api/user/profile
Response: { "template_count": 3, ... }

# Create template (increments template_count)
POST /api/templates/
- Returns 429 if template_count >= 5
- Increments template_count on success

# Delete template (decrements template_count)
DELETE /api/templates/{template_id}
- Decrements template_count (min 0)
```

**Frontend Integration**:
```typescript
// Fetch count on mount
const response = await fetch('/api/user/profile');
const { template_count } = await response.json();
const generationsLeft = 5 - template_count;

// Update UI after generation
setGenerationsLeft(prev => Math.max(0, prev - 1));

// Disable button when limit reached
disabled={generationsLeft <= 0}
```

**Key Changes from localStorage**:
- ❌ Remove: `localStorage.getItem('templateGenerations_${user.uid}')`
- ❌ Remove: `localStorage.setItem('templateGenerations_${user.uid}', count)`
- ✅ Add: Fetch from `/api/user/profile` on mount
- ✅ Add: Backend enforces limit with 429 error
- ✅ Benefit: Works across devices/browsers
