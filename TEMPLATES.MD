# Resume-Based Template Generation Feature - Implementation Plan

## Overview

Implement a feature allowing users to upload resumes (PDF) to Supabase Storage and generate personalized cold email templates using AI. The feature follows existing codebase patterns and architectural decisions.

## Architecture Decisions

Based on user requirements and existing patterns:

- **Upload Flow**: Frontend → Supabase Storage (direct upload via signed URLs from backend)
- **Generation**: Synchronous API call (5-15 second response, like `/api/user/init`)
- **Resume Policy**: Single resume per user (uploading new resume overwrites old)
- **Template Mutability**: Immutable (create/delete only, no editing)
- **Backend-First**: Backend validates JWT, performs all database operations

## Implementation Phases

### Phase 1: Configuration & Settings (30 min)

**File**: `config/settings.py`

Add Supabase Storage configuration:
```python
# Supabase Storage
supabase_storage_bucket: str = Field(default="resumes")
storage_url_expiry_seconds: int = Field(default=3600)
```

**File**: `.env` / `.env.example`

Add environment variables (with defaults above, these are optional):
```
SUPABASE_STORAGE_BUCKET=resumes
STORAGE_URL_EXPIRY_SECONDS=3600
```

### Phase 2: Database Models (1 hour)

**File**: `models/template.py` (Currently incomplete - needs implementation)

Complete the Template model following patterns from `models/email.py`:
```python
from uuid import uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Index
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database.base import Base

class Template(Base):
    __tablename__ = "templates"

    # Columns
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PG_UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    pdf_url = Column(String(500), nullable=False, comment="Supabase Storage URL for resume PDF")
    template_text = Column(Text, nullable=False, comment="Generated template content")
    user_instructions = Column(Text, nullable=False, comment="User guidance for template generation")
    created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)

    # Relationships
    user = relationship("User", back_populates="templates")

    # Indexes
    __table_args__ = (
        Index('ix_templates_user_id', 'user_id'),
        Index('ix_templates_created_at', 'created_at'),
        Index('ix_templates_user_created', 'user_id', 'created_at'),
    )

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "pdf_url": self.pdf_url,
            "template_text": self.template_text,
            "user_instructions": self.user_instructions,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }
```

**File**: `models/user.py`

Add template tracking and relationship:
```python
# Add after generation_count field
template_count = Column(
    Integer,
    nullable=False,
    default=0,
    comment="Number of templates generated by this user"
)

# Add to relationships section
templates = relationship(
    "Template",
    back_populates="user",
    cascade="all, delete-orphan",
    lazy="dynamic"
)
```

Update `to_dict()` method to include `template_count`.

**File**: `models/__init__.py`

Add Template import:
```python
from models.template import Template
__all__ = ["User", "Email", "Template"]
```

**Database Migration**:
```bash
alembic revision --autogenerate -m "add templates table and template_count to users"
alembic upgrade head
```

### Phase 3: Supabase Storage Integration (1 hour)

**File**: `services/supabase.py`

Add storage functions after existing client functions:
```python
def create_signed_upload_url(bucket: str, file_path: str, expires_in: int) -> dict:
    """
    Generate a signed URL for uploading files to Supabase Storage.

    Args:
        bucket: Storage bucket name
        file_path: Path within bucket (e.g., "user_id/resume.pdf")
        expires_in: URL expiry time in seconds

    Returns:
        dict with 'upload_url' and 'public_url'
    """
    client = get_supabase_client()
    signed_url = client.storage.from_(bucket).create_signed_upload_url(file_path)
    public_url = client.storage.from_(bucket).get_public_url(file_path)
    return {
        "upload_url": signed_url,
        "public_url": public_url
    }

def get_public_url(bucket: str, file_path: str) -> str:
    """Get public URL for a file in Supabase Storage."""
    client = get_supabase_client()
    return client.storage.from_(bucket).get_public_url(file_path)

def delete_file(bucket: str, file_path: str) -> bool:
    """Delete a file from Supabase Storage."""
    try:
        client = get_supabase_client()
        client.storage.from_(bucket).remove([file_path])
        return True
    except Exception:
        return False
```

### Phase 4: PDF Parsing Utility (1 hour)

**File**: `utils/pdf_parser.py` (NEW)

Create PDF text extraction utility:
```python
"""PDF parsing utilities for resume text extraction."""

import httpx
from pypdf import PdfReader
from io import BytesIO

async def extract_text_from_url(pdf_url: str, timeout: int = 30) -> str:
    """
    Fetch PDF from URL and extract text content.

    Args:
        pdf_url: Public URL to PDF file
        timeout: Request timeout in seconds

    Returns:
        Extracted text content

    Raises:
        ValueError: If PDF is invalid or text extraction fails
    """
    async with httpx.AsyncClient(timeout=timeout) as client:
        response = await client.get(pdf_url)
        response.raise_for_status()

        pdf_bytes = BytesIO(response.content)
        reader = PdfReader(pdf_bytes)

        if len(reader.pages) == 0:
            raise ValueError("PDF has no pages")

        text = ""
        for page in reader.pages:
            text += page.extract_text()

        text = clean_text(text)

        if len(text) < 50:
            raise ValueError("PDF appears to be scanned or contains too little text")

        return text

def clean_text(raw_text: str) -> str:
    """Clean and normalize extracted PDF text."""
    # Remove excessive whitespace
    text = " ".join(raw_text.split())
    return text.strip()
```

**Update**: `requirements.txt`
```
pypdf>=5.1.0,<6.0.0
httpx>=0.27.0,<1.0.0
```

### Phase 5: Template Generation Service (2 hours)

**File**: `prompts/template_generation.md` (NEW)

Create system prompt for template generation:
```markdown
You are an expert cold email writer helping users create personalized outreach templates for academic research opportunities.

Given a user's resume and specific instructions, generate a professional yet warm cold email template that:

1. **Length**: 150-250 words
2. **Tone**: Professional but personable, enthusiastic about research
3. **Structure**: Clear introduction, brief background, specific interest, polite ask
4. **Placeholders**: Use {{professor_name}}, {{university}}, {{research_area}} for personalization
5. **Resume Integration**: Naturally weave in relevant experience from the resume (courses, projects, skills)
6. **Customization**: Follow user's tone/style preferences from their instructions

IMPORTANT:
- DO NOT make up specific details about professors or their research
- Keep placeholders generic for later customization
- Highlight 2-3 relevant experiences from resume
- End with clear but non-pushy call-to-action
- Avoid clichés like "passionate" overuse

Output ONLY the email template text, no preamble or explanation.
```

**File**: `services/template_generator.py` (NEW)

Create template generation service:
```python
"""Template generation service using AI."""

import logfire
from utils.llm_agent import run_agent
from utils.pdf_parser import extract_text_from_url
from pathlib import Path

PROMPT_PATH = Path(__file__).parent.parent / "prompts" / "template_generation.md"

async def generate_template_from_resume(
    pdf_url: str,
    user_instructions: str,
    model: str = "anthropic:claude-sonnet-4.5-20250929"
) -> str:
    """
    Generate email template from resume PDF and user instructions.

    Args:
        pdf_url: Public URL to resume PDF in Supabase Storage
        user_instructions: User guidance for template generation
        model: AI model to use

    Returns:
        Generated template text

    Raises:
        ValueError: If PDF parsing fails or generation fails
    """
    with logfire.span("template_generation.generate"):
        # Extract text from PDF
        logfire.info("Extracting text from PDF", pdf_url=pdf_url)
        resume_text = await extract_text_from_url(pdf_url)
        logfire.info("PDF text extracted", length=len(resume_text))

        # Load system prompt
        system_prompt = PROMPT_PATH.read_text()

        # Create user prompt
        user_prompt = f"""**RESUME:**
{resume_text}

**USER INSTRUCTIONS:**
{user_instructions}

Generate a cold email template following the guidelines."""

        # Generate template using AI
        logfire.info("Generating template with AI")
        template_text = await run_agent(
            prompt=user_prompt,
            model=model,
            system_prompt=system_prompt,
            temperature=0.8,
            max_tokens=1500,
            retries=3,
            timeout=45.0
        )

        logfire.info("Template generated", length=len(template_text))
        return template_text
```

### Phase 6: API Schemas (45 min)

**File**: `schemas/template.py` (NEW)

Create Pydantic schemas:
```python
"""Pydantic schemas for template API endpoints."""

from pydantic import BaseModel, Field, ConfigDict, field_validator
from datetime import datetime
import uuid

class UploadUrlRequest(BaseModel):
    """Request schema for generating signed upload URL."""
    filename: str = Field(..., min_length=1, max_length=255, description="Filename (must end with .pdf)")

    @field_validator('filename')
    @classmethod
    def validate_pdf_extension(cls, v: str) -> str:
        if not v.lower().endswith('.pdf'):
            raise ValueError('Filename must end with .pdf')
        return v

    model_config = ConfigDict(
        json_schema_extra={
            "example": {"filename": "resume.pdf"}
        }
    )

class UploadUrlResponse(BaseModel):
    """Response schema for signed upload URL."""
    upload_url: str = Field(..., description="Signed URL for uploading file")
    public_url: str = Field(..., description="Public URL for accessing file after upload")
    expires_in: int = Field(..., description="URL expiry time in seconds")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "upload_url": "https://...",
                "public_url": "https://...",
                "expires_in": 3600
            }
        }
    )

class GenerateTemplateRequest(BaseModel):
    """Request schema for generating a template."""
    pdf_url: str = Field(..., min_length=10, max_length=500, description="Public URL to resume PDF")
    user_instructions: str = Field(..., min_length=10, max_length=2000, description="Guidance for template generation")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "pdf_url": "https://...",
                "user_instructions": "Create a warm, enthusiastic template highlighting my ML research experience"
            }
        }
    )

class TemplateResponse(BaseModel):
    """Response schema for template data."""
    id: uuid.UUID
    user_id: uuid.UUID
    pdf_url: str
    template_text: str
    user_instructions: str
    created_at: datetime

    model_config = ConfigDict(
        from_attributes=True,
        json_schema_extra={
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "user_id": "660e8400-e29b-41d4-a716-446655440001",
                "pdf_url": "https://...",
                "template_text": "Dear {{professor_name}}...",
                "user_instructions": "Warm and enthusiastic",
                "created_at": "2025-01-13T10:30:00Z"
            }
        }
    )

class ResumeUrlResponse(BaseModel):
    """Response schema for user's resume URL."""
    resume_url: str | None = Field(..., description="Public URL to user's resume, or null if none")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {"resume_url": "https://..."}
        }
    )
```

**File**: `schemas/auth.py`

Update UserResponse schema to include `template_count`:
```python
# Add to UserResponse class
template_count: int = Field(default=0, description="Number of templates generated")
```

### Phase 7: API Endpoints (3 hours)

**File**: `api/routes/template.py` (NEW)

Create template routes following patterns from `api/routes/user.py`:
```python
"""Template management API endpoints."""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
import logfire

from models.user import User
from models.template import Template
from database import get_db
from api.dependencies import get_current_user
from schemas.template import (
    UploadUrlRequest, UploadUrlResponse,
    GenerateTemplateRequest, TemplateResponse
)
from services.supabase import create_signed_upload_url, get_public_url
from services.template_generator import generate_template_from_resume
from utils.uuid_helpers import ensure_uuid
from config import settings

router = APIRouter(prefix="/api/templates", tags=["Templates"])

@router.post("/upload-url", response_model=UploadUrlResponse)
async def get_upload_url(
    request: UploadUrlRequest,
    current_user: User = Depends(get_current_user),
):
    """
    Generate signed URL for uploading resume to Supabase Storage.

    Single-resume policy: Always uploads to {user_id}/resume.pdf
    """
    with logfire.span("api.get_upload_url"):
        file_path = f"{current_user.id}/resume.pdf"

        try:
            result = create_signed_upload_url(
                bucket=settings.supabase_storage_bucket,
                file_path=file_path,
                expires_in=settings.storage_url_expiry_seconds
            )

            return UploadUrlResponse(
                upload_url=result["upload_url"],
                public_url=result["public_url"],
                expires_in=settings.storage_url_expiry_seconds
            )
        except Exception as e:
            logfire.error("Failed to create upload URL", error=str(e))
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to generate upload URL"
            )

@router.post("/", response_model=TemplateResponse, status_code=status.HTTP_201_CREATED)
async def create_template(
    request: GenerateTemplateRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Generate template from resume and user instructions.

    Synchronous operation (5-15 seconds). Creates Template record and increments user.template_count.
    """
    with logfire.span("api.create_template", user_id=str(current_user.id)):
        try:
            # Generate template
            template_text = await generate_template_from_resume(
                pdf_url=request.pdf_url,
                user_instructions=request.user_instructions
            )

            # Create database record
            new_template = Template(
                user_id=current_user.id,
                pdf_url=request.pdf_url,
                template_text=template_text,
                user_instructions=request.user_instructions
            )

            db.add(new_template)
            current_user.template_count += 1
            db.commit()
            db.refresh(new_template)

            logfire.info("Template created", template_id=str(new_template.id))
            return new_template

        except ValueError as e:
            db.rollback()
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Template generation failed: {str(e)}"
            )
        except Exception as e:
            db.rollback()
            logfire.error("Template creation failed", error=str(e))
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to create template"
            )

@router.get("/", response_model=list[TemplateResponse])
async def list_templates(
    limit: int = 20,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """List user's templates (paginated, newest first)."""
    with logfire.span("api.list_templates"):
        templates = db.query(Template).filter(
            Template.user_id == current_user.id
        ).order_by(
            Template.created_at.desc()
        ).limit(min(limit, 100)).offset(offset).all()

        return templates

@router.get("/{template_id}", response_model=TemplateResponse)
async def get_template(
    template_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get specific template by ID."""
    with logfire.span("api.get_template", template_id=template_id):
        try:
            template_uuid = ensure_uuid(template_id)
        except ValueError as e:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid template ID: {str(e)}"
            )

        template = db.query(Template).filter(
            Template.id == template_uuid,
            Template.user_id == current_user.id
        ).first()

        if not template:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Template not found"
            )

        return template

@router.delete("/{template_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_template(
    template_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Delete template by ID."""
    with logfire.span("api.delete_template", template_id=template_id):
        try:
            template_uuid = ensure_uuid(template_id)
        except ValueError as e:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid template ID: {str(e)}"
            )

        template = db.query(Template).filter(
            Template.id == template_uuid,
            Template.user_id == current_user.id
        ).first()

        if not template:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Template not found"
            )

        db.delete(template)
        current_user.template_count = max(0, current_user.template_count - 1)
        db.commit()

        logfire.info("Template deleted", template_id=template_id)
```

**File**: `api/routes/user.py`

Add resume URL endpoint:
```python
@router.get("/resume-url", response_model=ResumeUrlResponse)
async def get_resume_url(
    current_user: User = Depends(get_current_user),
):
    """Get public URL to user's resume."""
    from services.supabase import get_public_url
    from config import settings

    file_path = f"{current_user.id}/resume.pdf"
    resume_url = get_public_url(settings.supabase_storage_bucket, file_path)
    return ResumeUrlResponse(resume_url=resume_url)
```

**File**: `api/routes/__init__.py`

Export template router:
```python
from api.routes.template import router as template_router
__all__ = ["user_router", "email_router", "template_router"]
```

**File**: `main.py`

Include template router:
```python
from api.routes import user_router, email_router, template_router
app.include_router(template_router)
```

### Phase 8: Supabase Storage Policies

Configure in Supabase Dashboard:

**Bucket Setup**:
- Bucket name: `resumes`
- Public: Yes (for read access)
- File size limit: 5MB

**Storage Policies** (SQL):
```sql
-- Allow authenticated users to upload to their own folder
CREATE POLICY "Users can upload to own folder"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK (
    bucket_id = 'resumes'
    AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Allow public read access
CREATE POLICY "Public read access"
ON storage.objects FOR SELECT TO public
USING (bucket_id = 'resumes');

-- Allow users to update their own files
CREATE POLICY "Users can update own files"
ON storage.objects FOR UPDATE TO authenticated
USING (
    bucket_id = 'resumes'
    AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Allow users to delete their own files
CREATE POLICY "Users can delete own files"
ON storage.objects FOR DELETE TO authenticated
USING (
    bucket_id = 'resumes'
    AND (storage.foldername(name))[1] = auth.uid()::text
);
```

## Implementation Order

1. **Phase 1**: Configuration (30 min)
2. **Phase 2**: Database models + migration (1 hour)
3. **Phase 3**: Supabase storage functions (1 hour)
4. **Phase 4**: PDF parsing utility (1 hour)
5. **Phase 6**: API schemas (45 min) - *Do before Phase 5*
6. **Phase 5**: Template generation service (2 hours)
7. **Phase 7**: API endpoints (3 hours)
8. **Phase 8**: Supabase policies (15 min via dashboard)

**Total: ~9.5 hours**

## Testing Checklist

- [ ] Create signed upload URL
- [ ] Upload PDF via signed URL from frontend
- [ ] Generate template with uploaded PDF
- [ ] List templates (pagination)
- [ ] Get specific template
- [ ] Delete template (verify count decrements)
- [ ] Test authorization (can't access other user's templates)
- [ ] Test with scanned PDF (should fail gracefully)
- [ ] Test with corrupted PDF (should fail gracefully)
- [ ] Verify single-resume policy (upload overwrites)

## Security Considerations

✅ **Implemented**:
- JWT validation + local database check
- User ID from JWT only (never request body)
- Queries filtered by user_id
- Signed URLs with 1-hour expiration
- 404 instead of 403 (prevents info leakage)
- Input validation (filename, instructions length)
- Timeout on generation (45s)

⚠️ **To Configure in Supabase**:
- 5MB file size limit in bucket settings
- Proper MIME type validation in storage policies

## Critical Files Reference

**Models**:
- `models/template.py` - Complete Template model
- `models/user.py` - Add template_count and relationship

**Services**:
- `services/supabase.py` - Add storage functions
- `services/template_generator.py` - NEW: AI generation logic

**Utils**:
- `utils/pdf_parser.py` - NEW: PDF text extraction

**Schemas**:
- `schemas/template.py` - NEW: All template schemas
- `schemas/auth.py` - Update UserResponse

**Routes**:
- `api/routes/template.py` - NEW: 5 template endpoints
- `api/routes/user.py` - Add resume URL endpoint

**Config**:
- `config/settings.py` - Add storage settings
- `prompts/template_generation.md` - NEW: System prompt

## Notes

- Follow existing patterns from `models/email.py` and `api/routes/user.py`
- Use `logfire.span()` for observability on all operations
- Synchronous generation means users wait 5-15 seconds for response
- Single-resume policy simplifies storage management
- Templates are immutable (no edit endpoint needed)
